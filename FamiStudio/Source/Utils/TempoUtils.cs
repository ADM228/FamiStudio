using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace FamiStudio
{
    static class FamiStudioTempoUtils
    {
        private const int MinNoteLength = 1;
        private const int MaxNoteLength = 18;
        private const float BpmThreshold = 2.0f;
        private static readonly int[] GrooveLengths = new int[] { 2, 3, 4, 8 };

        // Here we only compare NTSC tempos, but that's ok, its just to get 
        // a list with a decent variety tempos.
        private static int[] GetGrooveLengthsForNoteLength(int noteLength)
        {
            var lengths = new List<int>();
            var bpm1 = 900.0f / noteLength;

            foreach (int grooveLen in GrooveLengths)
            {
                var bpm2 = (900.0f * grooveLen) / (grooveLen * noteLength - 1);

                // Avoid having tempos that are too similar. 
                if (Math.Abs(bpm2 - bpm1) < BpmThreshold)
                    break;

                lengths.Add(grooveLen);
            }

            return lengths.ToArray();
        }

        // This essentially build a table very similar to this:
        // http://famitracker.com/wiki/index.php?title=Common_tempo_values
        public static TempoInfo[] GetAvailableTempos(bool pal, int notesPerBeat = 4)
        {
            List<TempoInfo> tempos = new List<TempoInfo>();

            // Add last one.
            tempos.Add(new TempoInfo(new int[] { MaxNoteLength }, pal, notesPerBeat));

            for (int noteLen = MaxNoteLength - 1; noteLen >= MinNoteLength; noteLen--)
            {
                tempos.Add(new TempoInfo(new int[] { noteLen }, pal, notesPerBeat));

                var grooveLengths = GetGrooveLengthsForNoteLength(noteLen);

                foreach (int grooveLen in grooveLengths)
                {
                    var groove = new int[grooveLen];

                    for (int j = 0; j < grooveLen - 1; j++)
                        groove[j] = noteLen + 1;
                    groove[grooveLen - 1] = noteLen;

                    tempos.Add(new TempoInfo(groove, pal, notesPerBeat));

                    if (grooveLen > 2)
                    {
                        groove = new int[grooveLen];
                        groove[0] = noteLen + 1;
                        for (int j = 1; j < grooveLen; j++)
                            groove[j] = noteLen;

                        tempos.Add(new TempoInfo(groove, pal, notesPerBeat));
                    }
                }
            }

            // Sort.
            tempos.Sort((t1, t2) => t1.bpm.CompareTo(t2.bpm));

            //Debug.WriteLine($"NOTES PER BEAT {notesPerBeat}");
            //foreach (var tempo in tempos)
            //    Debug.WriteLine(tempo.bpm.ToString("n1"));

            //BuildTempoEnvelope(new[] { 7, 6, 6 }, 1, false);

            return tempos.ToArray();
        }

        public static float ComputeBpmForGroove(bool pal, int[] groove, int notesPerBeat)
        {
            var grooveNumFrames = 0;
            var grooveLength = 0;

            do
            {
                grooveNumFrames += Utils.Sum(groove);
                grooveLength += groove.Length;
            }
            while ((grooveLength % notesPerBeat) != 0);

            float numer = pal ? 3000.0f : 3600.0f;
            float denom = grooveNumFrames / (float)grooveLength * notesPerBeat;

            return numer / denom;
        }

        public static TempoInfo[] GetAvailableTemposForBeatLength(bool pal, int notesPerBeat)
        {
            var tempos = GetAvailableTempos(pal);

            foreach (var tempo in tempos)
                tempo.bpm = ComputeBpmForGroove(pal, tempo.groove, notesPerBeat);

            return tempos;
        }

        // Give a groove, like 7-6-6-6, returns all possible permutations.
        //  - 7-6-6-6
        //  - 6-7-6-6
        //  - 6-6-7-6
        //  - 6-6-6-7
        public static int[][] GetAvailableGrooves(int[] groove)
        {
            ValidateGroove(groove);

            // Get all permutations
            var permutations = new List<int[]>();
            Utils.Permutations(groove, permutations);

            return permutations.ToArray();
        }
        
        // Make sure the groove has been generated by us.
        public static bool ValidateGroove(int[] groove)
        {
            var min = Utils.Min(groove);
            var max = Utils.Max(groove);

            bool valid = false;
            if (min == max)
            {
                valid = 
                    groove.Length == 1   &&
                    min >= MinNoteLength &&
                    min <= MaxNoteLength;
            }
            else
            {
                int numMin = 0;
                int numMax = 0;

                for (int i = 0; i < groove.Length; i++)
                {
                    if (groove[i] == min)
                        numMin++;
                    else if (groove[i] == max)
                        numMax++;
                    else
                        return false;
                }

                valid = 
                    (max - min) <= 1 &&
                    (numMin == 1 || numMax == 1) && 
                    min >= MinNoteLength &&
                    min <= MaxNoteLength &&
                    max >= MinNoteLength &&
                    min <= MaxNoteLength &&
                    Array.IndexOf(GrooveLengths, groove.Length) >= 0;
            }

            Debug.Assert(valid);

            return valid;
        }

        private class CachedTempoEnvelope
        {
            public int[] groove;
            public int   groovePaddingMode;
            public bool  palSource;
            public byte[] tempoEnvelope;
        };

        private static List<CachedTempoEnvelope> cachedTempoEnvelopes = new List<CachedTempoEnvelope>();

        public static byte[] GetTempoEnvelope(int[] groove, int groovePaddingMode, bool palSource)
        {
            // Look in cache first.
            foreach (var cachedEnvelope in cachedTempoEnvelopes)
            {
                if (Utils.CompareArrays(cachedEnvelope.groove, groove) == 0 &&
                    cachedEnvelope.groovePaddingMode == groovePaddingMode &&
                    cachedEnvelope.palSource         == palSource)
                {
                    return cachedEnvelope.tempoEnvelope;
                }
            }

            // Otherwise build.
            var dstFactor = palSource ? 6 : 5;
            var srcFactor = palSource ? 5 : 6;
            var noteLength = Utils.Min(groove);
            var grooveNumFrames = Utils.Sum(groove);
            var grooveRepeatCount = 1;

            // Repeat the groove until we have something perfectly divisible by 6 (5 on PAL).
            while ((grooveNumFrames % srcFactor) != 0)
            {
                grooveNumFrames += Utils.Sum(groove);
                grooveRepeatCount++;
            }

            // Figure out how many frames that is on the playback machine.
            var adaptedNumFrames = grooveNumFrames / srcFactor * dstFactor;

            // Mark some frames as "important", this will typically be the first 
            // and last frame of the note. This will preserve the attack and 
            // 1-frame silence between notes.
            var importantFrames = new bool[grooveNumFrames];
            var frameIndex = 0;

            for (int i = 0; i < grooveRepeatCount; i++)
            {
                for (int j = 0; j < groove.Length; j++)
                {
                    if (groove[j] == noteLength)
                    {
                        importantFrames[frameIndex] = true;
                        importantFrames[frameIndex + noteLength - 1] = true;
                    }
                    else
                    {
                        if (groovePaddingMode != GroovePaddingType.Beginning || noteLength == 1)
                            importantFrames[frameIndex] = true;
                        else
                            importantFrames[frameIndex + 1] = true;

                        if (groovePaddingMode != GroovePaddingType.End || noteLength == 1)
                            importantFrames[frameIndex + noteLength] = true;
                        else
                            importantFrames[frameIndex + noteLength - 1] = true;
                    }

                    frameIndex += groove[j];
                }
            }

#if FALSE
            var numSkipFrames = palSource ? adaptedNumFrames - grooveNumFrames : grooveNumFrames - adaptedNumFrames;
            var bestScore  = int.MaxValue;
            var bestOffset = -1;

            for (int i = 0; i < srcFactor; i++)
            {
                var score = 0;

                frameIndex = i;
                for (int j = 0; j < numSkipFrames; j++)
                {
                    if (importantFrames[frameIndex])
                        score++;
                    frameIndex += srcFactor;
                }

                if (score < bestScore)
                {
                    bestScore  = score;
                    bestOffset = i;
                }
            }
#else
            // Start by distributing the skip (or double) frames evenly.
            var numSkipFrames = palSource ? adaptedNumFrames - grooveNumFrames : grooveNumFrames - adaptedNumFrames;
            var skipFrames = new bool[grooveNumFrames];

            frameIndex = srcFactor / 2;
            for (int i = 0; i < numSkipFrames; i++)
            {
                skipFrames[frameIndex] = true;
                frameIndex += srcFactor;
            }

            int GetFrameCost(int idx)
            {
                if (!skipFrames[idx])
                    return 0;

                var cost = 0;

                // Penalize important frames
                if (importantFrames[idx])
                    cost += srcFactor;

                // Look right for another skipped frame.
                for (int i = 1; i < srcFactor; i++)
                {
                    var nextIdx = idx + i;
                    if (nextIdx >= skipFrames.Length)
                        nextIdx -= skipFrames.Length;
                    if (skipFrames[nextIdx])
                    {
                        // The closer we are, the higher the cost.
                        cost += (srcFactor - i);
                        break;
                    }
                }

                // Look left for another skipped frame.
                for (int i = 1; i < srcFactor; i++)
                {
                    var prevIdx = idx - i;
                    if (prevIdx < 0)
                        prevIdx += skipFrames.Length;
                    // The closer we are, the higher the cost.
                    if (skipFrames[prevIdx])
                    {
                        cost += (srcFactor - i);
                        break;
                    }
                }

                return cost;
            }

            var frameCosts = new int[grooveNumFrames];

            // Optimize.
            for (int i = 0; i < 100; i++)
            {
                // Update costs.
                var maxCost = -10;
                var maxCostIndex = -1;
                var totalCost = 0;

                for (int j = 0; j < frameCosts.Length; j++)
                {
                    var cost = GetFrameCost(j);

                    frameCosts[j] = cost;
                    totalCost += cost;

                    if (cost > maxCost)
                    {
                        maxCost = cost;
                        maxCostIndex = j;
                    }
                }

                if (maxCost == 0)
                    break;

                var currentFrameCost = GetFrameCost(maxCostIndex);

                // Try to optimize the most expensive frame by moving it to the left.
                if (maxCostIndex > 0 && !skipFrames[maxCostIndex - 1] && !importantFrames[maxCostIndex - 1])
                {
                    Utils.Swap(ref skipFrames[maxCostIndex], ref skipFrames[maxCostIndex - 1]);
                    if (GetFrameCost(maxCostIndex - 1) < currentFrameCost)
                        continue;
                    Utils.Swap(ref skipFrames[maxCostIndex], ref skipFrames[maxCostIndex - 1]);
                }

                // Try to optimize the most expensive frame by moving it to the right.
                if (maxCostIndex < skipFrames.Length - 1 && !skipFrames[maxCostIndex + 1] && !importantFrames[maxCostIndex + 1])
                {
                    Utils.Swap(ref skipFrames[maxCostIndex], ref skipFrames[maxCostIndex + 1]);
                    if (GetFrameCost(maxCostIndex + 1) < currentFrameCost)
                        continue;
                    Utils.Swap(ref skipFrames[maxCostIndex], ref skipFrames[maxCostIndex + 1]);
                }

                break;
            }
#endif

            // Build the actual envelope.
            var lastFrameIndex = -1;
            var firstFrameIndex = -1;
            var envelope = new List<byte>();
            var sum = 0;

            for (int i = 0; i < skipFrames.Length; i++)
            {
                if (skipFrames[i])
                {
                    var frameDelta = i - lastFrameIndex;
                    envelope.Add((byte)(frameDelta + (palSource ? 1 : -1)));
                    sum += frameDelta;
                    lastFrameIndex = i;
                    if (firstFrameIndex < 0)
                        firstFrameIndex = i;
                }
            }

            if (palSource)
                envelope[0]--;

            var remainingFrames = skipFrames.Length - sum;
            if (remainingFrames != 0)
                envelope.Add((byte)(remainingFrames + firstFrameIndex + 1 + (palSource ? 1 : -1)));
            envelope.Add(0x80);

            var cacheEntry = new CachedTempoEnvelope();
            cacheEntry.groove = groove;
            cacheEntry.groovePaddingMode = groovePaddingMode;
            cacheEntry.palSource = palSource;
            cacheEntry.tempoEnvelope = envelope.ToArray();
            cachedTempoEnvelopes.Add(cacheEntry);

            return cacheEntry.tempoEnvelope;
        }
    }

    public class TempoInfo
    {
        public TempoInfo(int[] groove, bool pal, int notesPerBeat)
        {
            this.bpm = FamiStudioTempoUtils.ComputeBpmForGroove(pal, groove, notesPerBeat);
            this.groove = groove;
        }

        public float bpm;
        public int[] groove;
    }
}

